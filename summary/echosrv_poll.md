### echosrv_poll.cpp

#### 问题1

read可能并没有将connfd对应的接收缓冲区中的数据全部读完，那么connfd依然是活跃的

应该将数据保存在connfd的应用层接收缓冲区

#### 问题2

内核发送缓冲区满时，write不会阻塞（非阻塞套接字）

应用层应该有发送缓冲区，当内核中发送缓冲区满时，将数据写入应用层发送缓冲区

关注pollout事件（内核发送缓冲区可写），将应用层发送缓冲区的数据拷贝到内核发送缓冲区

数据都发送完毕，取消关注pollout事件

#### accept EMFILE的处理

太多文件，如果不进行处理的话，监听套接字的POLLIN始终处于高电平状态，不断触发accept并返回EMFILE，形成busy-loop

* 增加进程文件描述符的数目（大并发）
* 死等：返回EMFILE，等待
* 退出程序
* 关闭监听套接字，腾出一个文件描述符，什么时候重新打开
* 如果是epoll模型，可以改用edge trigger边沿触发（以上为电平触发）
* **推荐方式**：准备一个空闲的文件描述符，遇到EMFILE的情况，先关闭这个空闲文件，获得一个文件描述符名额，再accept拿到socket连接的文件描述符；随后立刻调用close，断开与客户端的连接，最后重新打开空闲文件，准备再次处理EMFILE的情况